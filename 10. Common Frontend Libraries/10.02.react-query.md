# 10.02 React Query (TanStack Query)

**React Query** is a library for **fetching, caching, and syncing server data**
in React applications.

It solves a very specific problem:

> **Server state is not the same as UI state.**

---

## What React Query is for

React Query manages **server state**, such as:

- data fetched from APIs
- loading states
- error states
- background refetching
- caching and cache invalidation

It does **not** manage:

- form state
- UI state (modals, toggles)
- client-only data

---

## Why server state is hard

Without React Query, you usually have to handle:

- `useEffect` for fetching
- `useState` for data, loading, errors
- manual refetching
- race conditions
- stale data
- duplicated requests across components

This leads to:

- boilerplate
- bugs
- inconsistent data

---

## Core idea

> **Fetch once, cache it, and keep it in sync automatically.**

React Query:

- caches API responses
- shares data between components
- refetches when needed
- updates UI automatically

You stop thinking about _when_ to fetch -
you describe _what_ data you need.

---

## Basic example

```tsx
import { useQuery } from "@tanstack/react-query";

function Users() {
  const { data, isLoading, error } = useQuery({
    queryKey: ["users"],
    queryFn: fetchUsers,
  });

  if (isLoading) return <p>Loading...</p>;
  if (error) return <p>Error</p>;

  return <UserList users={data} />;
}
```

What happens:

- data is fetched once
- cached automatically
- reused across components
- kept fresh in the background

---

## Setup (required once)

React Query must be configured at the app root.

```tsx
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

const queryClient = new QueryClient();

<QueryClientProvider client={queryClient}>
  <App />
</QueryClientProvider>
```

This provider enables caching and queries across the app.

Without it, useQuery and useMutation will not work.

---

## Query keys

Query keys identify **what data is being fetched**.

```ts
["users"]
["users", userId]
["posts", { page: 1 }]
```

Same key = same cached data.

Change the key → React Query fetches new data.

---

## Caching & refetching

React Query handles:

- caching responses
- refetching on:
  - window focus
  - network reconnect
  - interval (optional)

- deduping requests

This gives you **fresh data without manual logic**.

---

## Mutations (writing data)

For POST / PUT / DELETE requests.

```tsx
import { useMutation } from "@tanstack/react-query";

const mutation = useMutation({
  mutationFn: createUser,
  onSuccess: () => {
    queryClient.invalidateQueries(["users"]);
  },
});
```

Why this is important:

- server updates
- cache stays in sync
- UI updates automatically

---

## React Query vs useEffect

**With `useEffect`:**

- manual state
- manual loading flags
- manual refetching
- easy to get wrong

**With React Query:**

- declarative data fetching
- caching out of the box
- fewer bugs
- cleaner components

---

## When React Query is a great choice

Use it when:

- your app talks to APIs
- data is shared across components
- caching matters
- background updates matter
- you want predictable data flow

It is a **standard choice** in modern React apps.

---

## When it may be overkill

You might skip it when:

- data is truly static
- app is very small
- only one fetch on page load

Even then, many teams still use it for consistency.

---

## Mental model

- UI state → `useState`
- Form state → React Hook Form
- Server state → React Query

Think:

> “If it comes from the server, React Query owns it.”

---

## Summary

- React Query manages **server state**
- It handles fetching, caching, and syncing
- Eliminates boilerplate and race conditions
- Keeps UI and server data in sync
- A strong default for data-driven React apps

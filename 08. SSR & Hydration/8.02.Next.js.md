# 8.02 Next.js Rendering Modes (SSR, SSG, ISR, App Router)

Next.js is a React framework that supports **multiple rendering strategies**
out of the box.

It lets you decide **how each page is rendered**
based on data needs, performance, and UX.

---

## What Next.js adds on top of React

Plain React only gives you **CSR**.

Next.js adds:

- Server-Side Rendering (SSR)
- Static Site Generation (SSG)
- Incremental Static Regeneration (ISR)
- Streaming & Server Components (App Router)

This makes rendering a **per-page (or per-component) decision**.

---

## Pages Router vs App Router (important context)

Next.js currently has **two routing systems**:

### Pages Router (older, still widely used)

- `pages/` directory
- data fetching via special functions
- file-based routing

### App Router (new, recommended)

- `app/` directory
- React Server Components by default
- data fetching via `fetch`
- streaming & layouts built in

The **core concepts are the same**, but the APIs differ.

---

## Server-Side Rendering (SSR) in Next.js

### What SSR means in Next.js

SSR in Next.js means:

- HTML is generated **on every request**
- data is fetched **at request time**
- page is always fresh

---

### SSR in Pages Router

```ts
export async function getServerSideProps() {
  return {
    props: {
      time: new Date().toISOString(),
    },
  };
}
```

Key points:

- runs on every request
- runs only on the server
- can access cookies, headers, auth
- slower than static pages

---

### SSR in App Router

In the App Router:

- **Server Components are SSR by default**
- data fetching happens on the server automatically

Example:

```ts
const data = await fetch("https://api.example.com/data", {
  cache: "no-store",
});
```

This tells Next.js:

> “Render this on every request.”

---

### When to use SSR

Use SSR when:

- content is user-specific
- auth or cookies matter
- data must always be fresh
- SEO is important
- dashboards or account pages

---

## Static Site Generation (SSG) in Next.js

### What SSG means in Next.js

SSG means:

- HTML is generated **at build time**
- pages are deployed as static files
- served instantly from a CDN (Content Delivery Network)

---

### SSG in Pages Router

```ts
export async function getStaticProps() {
  return {
    props: {
      posts: [],
    },
  };
}
```

Optional dynamic routes:

```ts
export async function getStaticPaths() {
  return {
    paths: [],
    fallback: false,
  };
}
```

---

### SSG in App Router

In the App Router, **static generation is the default when data is cacheable**.

```ts
const data = await fetch("https://api.example.com/posts");
```

By default:

- data is cached
- page is statically generated
- no server work at request time

---

### When to use SSG

Use SSG when:

- content changes rarely
- pages are public
- performance matters most
- SEO is important
- marketing pages, blogs, docs

---

## Incremental Static Regeneration (ISR)

### What ISR is

ISR is a **hybrid between SSG and SSR**.

It means:

- page is generated at build time
- but can be **re-generated later**
- without rebuilding the whole site

---

### ISR in Pages Router

```ts
export async function getStaticProps() {
  return {
    props: { posts: [] },
    revalidate: 60,
  };
}
```

This means:

- page is regenerated at most once every 60 seconds
- users get cached content
- background regeneration happens automatically

---

### ISR in App Router

```ts
const data = await fetch("https://api.example.com/posts", {
  next: { revalidate: 60 },
});
```

This is now the **preferred approach**.

---

### When to use ISR

Use ISR when:

- content updates occasionally
- full rebuilds are expensive
- you want CDN speed + freshness
- blogs, news, listings, catalogues

---

## Client-Side Rendering (CSR) in Next.js

Even in Next.js, CSR still exists.

CSR means:

- HTML is minimal or empty
- data is fetched in the browser
- content appears after JS loads

Example:

```ts
useEffect(() => {
  fetch("/api/data").then(...);
}, []);
```

CSR is useful when:

- SEO is irrelevant
- data is highly interactive
- content is behind login
- updates happen very frequently

---

## Mixing rendering strategies (!)

Next.js allows **mixing strategies**:

- SSG page
- with SSR data
- and CSR widgets inside

Example:

- Page shell → SSG
- User-specific section → SSR
- Live updates → CSR

This is **normal and recommended**.

---

## Hydration in Next.js

In all cases:

- HTML is sent first
- React hydrates on the client
- event handlers attach
- app becomes interactive

Hydration happens for:

- SSR pages
- SSG pages
- ISR pages

Server rendering ≠ no JavaScript.

---

## Performance implications

**SSG**

- fastest
- cheapest
- most cacheable

**ISR**

- almost as fast as SSG
- controlled freshness

**SSR**

- slower
- more server load
- more flexible

Choose **the simplest option that works**.

---

## Common mistakes in Next.js rendering

- using SSR everywhere “just in case”
- disabling caching unnecessarily
- fetching data on client when server is better
- rebuilding entire site instead of using ISR
- not understanding default behaviour in App Router

---

## Mental model

- SSG → build once
- ISR → rebuild sometimes
- SSR → render every request
- CSR → render in browser
- App Router → server-first by default

Ask:

> “When should this HTML be created?”

---

## Summary

- Next.js supports multiple rendering strategies
- SSG is the default in the App Router
- SSR is used for dynamic, user-specific pages
- ISR combines speed with freshness
- CSR is still useful for interactive data
- Rendering is a per-page or per-component choice
- Mixing strategies is normal and powerful

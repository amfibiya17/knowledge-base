# 0.04 Sync Clients Explained

This file explains **how multiple users and multiple browser tabs
stay consistent with the same data**.

It answers the question:

> “If many people (or tabs) use the app at the same time, how do they stay in sync?”

---

## What a “client” is

A **client** is:

- a browser tab
- a mobile app
- any frontend instance using the app

If you open the same app in:

- two browser tabs
- two different devices
- two different users

You now have **multiple clients**.

---

## The core problem

Clients are **independent**.

Each one has:

- its own memory
- its own state
- its own UI

If one client changes data:

- how do others know?
- when should they update?
- what if two clients change data at the same time?

This is the **sync problem**.

---

## Simple example

User A and User B are on the same page.

1. User A edits a record
2. User B still sees old data
3. User B refreshes → now sees update

Without syncing, updates are **delayed or invisible**.

---

## Common syncing strategies

### 1. Refresh-based syncing (simplest)

Clients update only when:

- page refreshes
- navigation happens

Pros:

- easy
- no extra logic

Cons:

- stale data
- poor user experience

---

### 2. Polling

Client asks the server:

> “Any updates?”  
> every X seconds.

```text
Client → Server → Client → Server → ...
```

Pros:

- simple to implement

Cons:

- extra requests
- still not real-time

---

### 3. Refetch on events (very common)

Client refetches data when:

- form is submitted
- mutation completes
- user focuses the tab
- route changes

This is how many React apps work.

Example tools:

- React Query
- SWR (Stale-While-Revalidate)

Pros:

- efficient
- predictable

Cons:

- still not real-time

---

### 4. Real-time syncing

Server **pushes updates** to clients.

Techniques:

- WebSockets
- Server-Sent Events
- subscriptions

Pros:

- real-time updates
- shared state feels live

Cons:

- more complex
- harder to scale

---

## Tabs vs users

### Multiple tabs (same user)

Problems:

- stale cache
- duplicated state
- conflicting updates

Solutions:

- refetch on focus
- `localStorage` + `storage` events
- shared workers

---

### Multiple users (different users)

Problems:

- conflicting edits
- race conditions
- outdated views

Solutions:

- server as source of truth
- optimistic updates + rollback
- versioning / timestamps

---

## Source of truth

To sync clients reliably:

> **The server is usually the source of truth**

Clients:

- display data
- request changes
- never assume they’re authoritative

---

## Optimistic vs pessimistic updates

### Optimistic update

- UI updates immediately
- server confirms later

Feels fast, but needs rollback handling.

---

### Pessimistic update

- wait for server response
- then update UI

Safer, but slower.

---

## Why this matters in frontend work

Sync problems cause:

- “Why did my change disappear?”
- “Why does my screen differ from theirs?”
- “Why did this overwrite my update?”

Understanding sync helps you:

- design better state flows
- choose correct tools
- avoid data bugs

---

## Mental model

Think of clients like:

- many whiteboards
- one central notebook (server)

Whiteboards can be wrong.
The notebook is always correct.

---

## Summary

- Each browser/app is a separate client
- Clients don’t auto-sync
- Syncing requires deliberate strategy
- Server is the source of truth
- Polling, refetching, and real-time are options
- Sync issues are state problems, not UI problems

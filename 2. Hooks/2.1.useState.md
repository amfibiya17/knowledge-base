# 2.1 useState

This file introduces the `useState` hook.
`useState` is the most fundamental React hook and is used to add **state** to functional components.

---

## What `useState` is

`useState` is a React hook that allows a component to:

- store state
- update state
- trigger a re-render when state changes

Without `useState`, functional components cannot hold changing data.

---

## Basic syntax

```jsx
const [state, setState] = useState(initialValue);
```

Here:

- `state` is the current value
- `setState` is a function used to update the value
- `initialValue` is used only on the first render

---

## Example

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  return <button onClick={() => setCount(count + 1)}>Count: {count}</button>;
}
```

---

## What happens here

- `count` is stored in state
- clicking the button calls `setCount`
- state is updated
- the component re-renders
- the UI reflects the new state

**State changes always trigger a re-render.**

---

## Initial state

The initial value passed to `useState`:

- is used only on the **first render**
- is ignored on subsequent re-renders

```jsx
const [name, setName] = useState("Anna");
```

---

## Updating state

State should never be changed directly.

❌ Wrong:

```jsx
count = count + 1;
```

✅ Correct:

```jsx
setCount(count + 1);
```

React needs setState to know that something changed.

---

## State updates are asynchronous (important)

State updates do not happen immediately.

```jsx
setCount(count + 1);
console.log(count); // still old value
```

React schedules the update and re-renders later.

---

## Functional updates

When the new state depends on the previous state, use the functional form:

```jsx
setCount((prevCount) => prevCount + 1);
```

This avoids bugs when multiple updates happen quickly.

---

## Multiple state values

You can call `useState` multiple times in a component:

```jsx
const [name, setName] = useState("");
const [age, setAge] = useState(0);
```

Each state value is independent.

---

## What `useState` does NOT do

- It does not merge objects automatically
- It does not update state deeply
- It does not persist state across page reloads

State exists only while the component is mounted.

---

## Common mistakes

- Updating state directly
- Forgetting that updates are asynchronous
- Using stale state instead of functional updates
- Putting too much unrelated data into one state variable

---

## Mental model

- State = data that changes over time
- `useState` gives you a value + a setter
- Calling the setter tells React: “Re-render this component”
- UI is always derived from state

---

## Summary

- `useState` adds state to functional components
- State changes trigger re-renders
- State must be updated using the setter function
- Updates are asynchronous
- Functional updates prevent stale state bugs
- `useState` is the foundation of React hooks

# 2.5 useMemo

This file introduces the `useMemo` hook.  
`useMemo` is used to **memoise expensive calculations** so they are not re-run on every render.

---

## What `useMemo` is

`useMemo` is a React hook that:

- caches the result of a calculation
- re-computes the value only when dependencies change
- helps avoid unnecessary work during rendering

It is a **performance optimisation**, not a requirement.

---

## Basic syntax

```jsx
const memoisedValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]);
```

The memoised function runs during rendering when React needs the value.

Here:

- the function contains the calculation
- the dependency array controls when it re-runs
- the returned value is cached between renders

---

## Example: expensive calculation

```jsx
function Example({ items }) {
  const total = useMemo(() => {
    return items.reduce((sum, item) => sum + item.price, 0);
  }, [items]);

  return <div>Total: {total}</div>;
}
```

Here:

- the calculation runs only when `items` changes
- re-renders caused by other state do not re-run it
- React reuses the cached value

---

## What happens when dependencies change

- component renders
- React compares dependency values
- if any dependency changed → calculation runs
- new value is cached
- component continues rendering

If dependencies **do not change**, the cached value is reused.

---

## Why `useMemo` exists

`useMemo` helps when:

- calculations are expensive
- renders happen frequently
- derived values slow down rendering
- you want predictable performance

Without `useMemo`, calculations run on **every render**.

---

## What `useMemo` does NOT do

- It does not prevent re-renders
- It does not memoise components (that’s `memo`)
- It does not make code faster by default
- It does not replace good state design

Using `useMemo` everywhere can make code **worse**, not better.

---

## Common mistakes

- Using `useMemo` for cheap calculations
- Forgetting dependencies
- Over-optimising too early
- Using it to “fix” unnecessary re-renders
- Using `useMemo` instead of fixing component structure

If a calculation is cheap, **don’t memoise it**.

---

## Mental model

- Render → React asks for a value
- `useMemo` → “Can I reuse the old one?”
- Dependencies unchanged → reuse cached value
- Dependencies changed → recompute

`useMemo` trades memory for computation.

---

## When to use `useMemo`

Use it when:

- a calculation is expensive
- the value is derived from props or state
- the calculation runs often
- performance is measurably affected

> Typical use cases include filtering large lists, processing heavy data, and stabilising derived values used across renders.

---

## Summary

- `useMemo` memoises computed values
- It re-runs only when dependencies change
- It is a performance optimisation
- It does not stop re-renders
- Use it sparingly and intentionally
- Prefer clarity over premature optimisation

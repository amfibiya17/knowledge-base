# 6.03 Virtualization (Windowing Large Lists)

**Virtualization** is a performance technique used to render **only what the user can see**,
instead of rendering **everything at once**.

It is especially important when working with **large lists or tables**.

---

## What problem virtualization solves

Rendering large lists causes problems like:

- slow initial render
- long JavaScript execution
- janky scrolling
- blocked main thread
- high memory usage

Example problem:

```jsx
items.map((item) => <Row key={item.id} />);
```

If `items.length = 10,000`
React tries to render **10,000 components**.

That is expensive.

---

## What virtualization is

Virtualization means:

- render **only visible items**
- reuse DOM nodes while scrolling
- keep the DOM **small and fast**

Most off-screen items are not rendered (only a small buffer is kept).

To the user, it still _looks_ like a full list.

---

## Core idea

Instead of this:

> Render 10,000 rows.

You do this:

> Render ~20–50 rows.
> Update them as the user scrolls.

---

## How virtualization works

- container has a fixed height
- list has a large virtual height
- only visible items are mounted
- items are positioned using `transform` or `top`

As you scroll:

- old items unmount
- new items mount
- DOM size stays small

---

## Common virtualization libraries

The most common libraries in React:

### react-window (most common)

- small
- fast
- simple API
- maintained by React team member

### react-virtualized (older)

- more features
- heavier
- more complex

Today, **react-window** is usually preferred.

---

## Basic example (react-window)

```jsx
import { FixedSizeList as List } from "react-window";

<List height={400} itemCount={10000} itemSize={40} width="100%">
  {({ index, style }) => <div style={style}>Row {index}</div>}
</List>;
```

What happens:

- only visible rows are rendered
- scrolling stays smooth
- DOM stays small

---

## Fixed vs variable size items

### Fixed size

- all rows have same height
- easiest and fastest
- best performance

```js
itemSize={40}
```

---

### Variable size

- rows have different heights
- more complex
- slightly slower

Requires measuring item heights.

Use only when necessary.

---

## When virtualization is necessary

You **should use virtualization** when:

- lists have hundreds or thousands of items
- tables feel slow
- scrolling stutters
- Performance tab shows long render tasks

Typical examples:

- search results
- logs
- tables
- dashboards
- infinite feeds

---

## When virtualization is NOT needed

Virtualization is **overkill** when:

- list is small (< 100 items)
- UI is simple
- performance is already fine
- layout is very complex

Virtualization adds complexity.

Do not use it “just in case”.

---

## Virtualization vs pagination

**Pagination**

- limits number of items
- simpler
- page-based UX

**Virtualization**

- continuous scrolling
- better UX for large datasets
- more complex

Many apps use **both**:

- pagination on backend
- virtualization on frontend

---

## Virtualization and accessibility

Virtualized lists can cause a11y issues:

- screen readers may not “see” off-screen items
- keyboard navigation may break
- focus can jump unexpectedly

Best practices:

- avoid virtualizing critical navigation
- test with keyboard and screen readers
- ensure focus is managed correctly

Performance should not break accessibility.

---

## Mental model

- Large list → heavy render
- Virtualization → render only what’s visible
- Small DOM → fast UI
- Scroll → recycle items

Think:

> “Do we really need all rows in the DOM right now?”

---

## Summary

- Virtualization renders only visible items
- It dramatically improves performance for large lists
- `react-window` is the most common solution
- Use it for thousands of items, not tens
- It adds complexity - use intentionally
- Always consider accessibility

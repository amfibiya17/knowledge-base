# 6.05 Dynamic Imports (Code Splitting)

**Dynamic imports** allow you to load JavaScript **only when it is needed**,
instead of loading everything upfront.

Dynamic imports are a common way to implement **code splitting**.

It is a key optimisation for **large React applications**.

---

## What problem dynamic imports solve

Without dynamic imports:

- the entire app bundle loads at once
- initial load is slower
- users download code they may never use

Example problem:

- admin pages loaded for all users
- heavy components loaded even if not visited
- large libraries included on first load

Dynamic imports solve this by **deferring code loading**.

---

## What dynamic imports are

Dynamic imports let you:

- split your code into smaller chunks
- load chunks only when needed
- reduce initial bundle size

Instead of:

```js
import HeavyComponent from "./HeavyComponent";
```

You load it **dynamically**:

```js
import("./HeavyComponent");
```

---

## Dynamic imports in React

React provides `React.lazy` for dynamic imports.

Example:

```jsx
import { Suspense, lazy } from "react";

const HeavyComponent = lazy(() => import("./HeavyComponent"));

function App() {
  return (
    <Suspense fallback={<div>Loading...</div>}>
      <HeavyComponent />
    </Suspense>
  );
}
```

What happens:

- `HeavyComponent` is not loaded initially
- React loads it only when rendered
- fallback UI is shown while loading

---

## `Suspense`

Components loaded with `React.lazy` must be wrapped in `Suspense`.

`Suspense`:

- shows a fallback while loading
- prevents crashes
- handles async loading gracefully

Example fallback options:

- loading spinner
- skeleton UI
- placeholder content

---

## Common use cases for dynamic imports

Dynamic imports are ideal for:

- large components
- rarely visited pages
- modals and dialogs
- admin or settings pages
- heavy third-party libraries
- charts and maps

Rule of thumb:

> If not everyone needs it immediately → load it later.

---

## Dynamic imports and routing

Dynamic imports work very well with routing.

Example:

```jsx
const SettingsPage = lazy(() => import("./SettingsPage"));
```

The page is only loaded **when the route is visited**.

Most routers (including Next.js) handle this automatically.

---

## Dynamic imports in Next.js

Next.js provides its own helper:

```tsx
import dynamic from "next/dynamic";

const Chart = dynamic(() => import("./Chart"), {
  loading: () => <p>Loading chart...</p>,
});
```

Benefits:

- no need for `Suspense` in some cases
- better SSR control
- can disable SSR if needed

```ts
dynamic(() => import("./Map"), { ssr: false });
```

Useful for browser-only libraries.

---

## Dynamic imports vs lazy loading data

Important distinction:

- **Dynamic imports** → load JavaScript code
- **Data fetching** → load data from API

They solve different problems.

You often use **both together**:

- dynamically load component
- fetch data inside it

---

## Performance impact

Dynamic imports improve:

- initial load time
- time to interactive
- perceived performance

But they also:

- add loading states
- create more network requests

Used well → big win

Used badly → fragmented UX

---

## When NOT to use dynamic imports

Avoid dynamic imports when:

- component is used immediately on first load
- component is very small
- splitting creates too many chunks
- UX suffers from frequent loading states

Do not split **everything**.

Dynamic imports reduce **download cost**, not execution cost.

---

## Mental model

- Initial bundle → critical code
- Dynamic chunks → optional code
- Render → trigger load
- Fallback → temporary UI

Think:

> “Does the user need this code right now?”

---

## Summary

- Dynamic imports split code into smaller chunks
- Code loads only when needed
- React uses `React.lazy` + `Suspense`
- Next.js provides `dynamic()`
- Great for large or rarely used components
- Improves initial load performance
- Adds loading complexity
- Use intentionally, not everywhere

# 6.07 Web Workers

**Web Workers** allow you to run JavaScript **off the main thread**.

They are used to handle **heavy computations** without blocking the UI.

They solve the problem:

> “My app freezes while doing work.”

---

## The main problem Web Workers solve

In the browser, JavaScript normally runs on the **main thread**.

The main thread is responsible for:

- running JavaScript
- handling user input
- updating the UI
- rendering and painting

Important rule:

> **If the main thread is busy, the UI freezes.**

Examples of problematic work on the main thread:

- large calculations
- data processing
- parsing big JSON
- sorting large arrays
- image processing
- complex transformations

This causes:

- laggy UI
- frozen clicks
- janky scrolling

---

## What Web Workers are

A **Web Worker** is:

- a separate background thread
- running JavaScript
- with no access to the DOM

Key properties:

- runs in parallel to the main thread
- communicates via messages
- cannot touch the UI directly

UI stays responsive while work happens elsewhere.

---

## Main thread vs Worker

**Main thread**

- handles UI
- handles events
- renders content

**Worker**

- does heavy computation
- processes data
- sends results back

They talk via **message passing**.

---

## Basic idea

```text
Main thread → send data → Worker

Worker → process → send result → Main thread
```

No shared variables.
No direct DOM access.

---

## Basic example

### Worker file

```js
// worker.js
self.onmessage = (event) => {
  const result = event.data * 2;
  self.postMessage(result);
};
```

---

### Main thread

```js
const worker = new Worker("worker.js");

worker.onmessage = (event) => {
  console.log(event.data);
};

worker.postMessage(10);
```

Result:

- main thread stays free
- heavy work runs in the worker

---

## Communication model

Workers use **postMessage**.

That means:

- data is usually cloned (structured clone)
- not shared by default
- some objects can be transferred instead of copied (transferables)

Implications:

- sending large objects is expensive
- frequent messaging can be slow
- you should batch work when possible

Some advanced setups use `SharedArrayBuffer`, but it requires special security headers.

---

## What Web Workers CANNOT do

Workers cannot:

- access the DOM
- read or modify HTML
- use `window`
- directly update React state

Workers are **logic-only**.

UI updates must happen on the main thread.

---

## When Web Workers are a good idea

Use Web Workers when:

- heavy computation blocks the UI
- Performance tab shows long JS tasks
- calculations run on user interaction
- data processing happens on the client
- work can be done independently of UI

Common use cases:

- data filtering / sorting
- charts and analytics
- search indexing
- image or video processing
- crypto / hashing
- PDF generation

---

## When Web Workers are NOT needed

Do NOT use Web Workers when:

- work is small or fast
- performance is already fine
- problem is too many re-renders
- bottleneck is network or rendering
- logic needs frequent DOM access

Workers fix **CPU (Central Processing Unit) problems**, not bad architecture.

---

## Web Workers in React apps

React does not change how workers work.

Typical pattern:

- React component triggers work
- sends data to worker
- worker processes
- result updates React state

Workers are often wrapped in:

- custom hooks
- utility services
- libraries

---

## Libraries that use Web Workers internally

You may already be using them indirectly:

- charting libraries
- code editors (Monaco)
- PDF libraries
- image tools
- data visualisation tools

Workers are often hidden behind APIs.

---

## Trade-offs of Web Workers

Pros:

- UI stays responsive
- true parallelism
- great for CPU-heavy tasks

Cons:

- more complexity
- harder debugging
- message-passing overhead
- extra build configuration sometimes needed

Use them intentionally.

---

## Mental model

- Main thread → UI & interaction
- Worker → heavy thinking
- Messages → communication
- No DOM in workers

Think:

> “Can this work happen without touching the UI?”

If yes → worker candidate.

---

## Summary

- Web Workers run JS off the main thread
- They prevent UI freezing during heavy work
- Communication is message-based
- They cannot access the DOM
- Best for CPU-intensive tasks
- Not needed for most everyday logic
- Use only when Performance tab shows blocking JS
- Powerful, but adds complexity

# 5.04 Utility Libraries

Utility libraries provide **predefined CSS classes**
that you use directly in your markup to style UI.

Instead of writing custom CSS,
you compose styles using **small, single-purpose classes**.

Examples include:

- **Tailwind CSS**
- utility helper libraries
- reset / normalisation layers (often included)

---

## What “utility” means

A utility class does **one thing**:

```html
<div class="p-4 text-center bg-white"></div>
```

Each class represents a **single CSS rule**:

- `p-4` → padding
- `text-center` → text alignment
- `bg-white` → background colour

You build UI by **combining utilities**.

---

## Tailwind CSS

Tailwind is a **utility-first CSS framework**.

Key ideas:

- no custom class names
- styles applied directly in JSX / HTML
- design tokens built in
- responsive and state variants included

Example:

```tsx
<button className="px-4 py-2 bg-blue-600 text-white rounded">Click</button>
```

No CSS file is required for this component.

---

## Why utility libraries exist

Utility libraries solve problems like:

- slow CSS iteration
- naming CSS classes
- large, hard-to-maintain stylesheets
- context switching between CSS and JSX

They offer:

- fast development
- consistent design
- fewer custom styles
- predictable behaviour

---

## Reset / normalisation

Most utility libraries include a **reset layer**.

For example, Tailwind includes **Preflight**, which:

- normalises browser styles
- removes default margins
- fixes inconsistent element behaviour

This reset:

- runs globally
- provides a clean baseline
- replaces the need for a separate reset file

So when using Tailwind:

> Reset CSS is usually **built in**, not written manually.

---

## When utility libraries work well

Utility libraries are a good fit when:

- speed of development matters
- design system is consistent
- teams want fewer CSS files
- components are simple and composable
- rapid UI changes are common

---

## When utility libraries are NOT ideal

Utility libraries can be a bad fit when:

- markup becomes hard to read
- complex conditional styling is needed
- designers expect semantic class names
- teams prefer separation of concerns
- long class strings reduce clarity

Example problem:

```tsx
<div className="flex items-center justify-between px-6 py-4 bg-white border border-gray-200 rounded-lg shadow-sm">
```

This can become noisy.

---

## Utility Libraries vs CSS Modules

**Utility libraries**

- styles live in markup
- no custom class names
- very fast iteration
- harder to refactor visually

**CSS Modules**

- styles live in CSS files
- semantic class names
- cleaner JSX
- more structure

---

## Utility Libraries vs CSS-in-JS

Utility libraries:

- no runtime styling logic
- no JS-generated CSS
- simple and predictable

CSS-in-JS:

- dynamic styles via props
- theme logic in JS
- more flexibility

Choose based on **complexity**, not trends.

---

## Common mistakes

- mixing utilities with lots of custom CSS
- not using design tokens consistently
- extremely long class strings
- using utilities to fix layout issues instead of structure
- switching styling approaches mid-project

Pick **one main approach** and stick to it.

---

## Mental model

- Utility class → one CSS rule
- Many utilities → one component style
- Reset → global baseline (the system first neutralises browser defaults)
- Design tokens → consistency

---

## Summary

- Utility libraries provide small, reusable CSS classes
- Tailwind is the most common example
- Resets are often included automatically
- Great for fast, consistent UI development
- Can hurt readability if overused
- Not a replacement for good structure or design
- Use intentionally, not by default

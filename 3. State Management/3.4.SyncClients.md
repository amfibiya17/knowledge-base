# 3.4 Sync Clients (Server State)

This section explains **client–server synchronisation**  
(often called **server state management**).

Sync clients are tools that help React apps:

- fetch data from a server
- keep it up to date
- handle loading, errors, caching, and re-fetching

They solve a **different problem** than Redux or Context.

---

## What “Sync Clients” means

Sync clients manage **server-owned state**, not UI state.

Server state is data that:

- lives on a backend (API, database)
- can change outside the user’s control
- can become stale
- must be re-fetched or synchronised

Examples of server state:

- list of users from an API
- products, orders, comments
- user profile fetched from backend
- permissions, flags, remote config

---

## Client state vs Server state

### Client state

- owned by the UI
- updated by user actions
- fully controlled by React

Examples:

- modal open / closed
- selected tab
- form input values
- filters, toggles

Handled well by:

- `useState`
- Context
- Redux
- Zustand, etc.

---

### Server state

- owned by the server
- fetched asynchronously
- can change without your app knowing
- can become stale

Problems to solve:

- loading states
- error handling
- caching
- refetching
- background updates

This is where **sync clients** shine.

---

## Why normal state tools are not enough

Using Redux or Context for server data leads to:

- lots of boilerplate
- manual loading and error handling
- manual caching
- complex invalidation logic

Example problems:

- when should data refetch?
- how long is it valid?
- what happens when a mutation succeeds?

Sync clients solve these automatically.

---

## What sync clients do for you

Sync clients usually handle:

- data fetching
- caching
- background refetching
- loading & error states
- deduplication
- retries
- request cancellation
- stale data management

All with **very little code**.

---

## Common Sync Client libraries

Most popular options today:

- **React Query (TanStack Query)** - most common
- **RTK Query** (Redux ecosystem)
- **SWR** (Vercel)
- **Apollo Client** (GraphQL)

---

## Example mental model (React Query)

Instead of thinking:

> “How do I store this data?”

You think:

> “How do I sync this data with the server?”

Data is treated as a **cache of server data**, not app state.

---

## Example idea (conceptual)

```js
const { data, isLoading, error } = useQuery({
  queryKey: ["users"],
  queryFn: fetchUsers,
});
```

Here:

- data is fetched automatically
- loading and error states are handled
- data is cached
- refetching happens when needed

You do not store this data in Redux or Context.

---

## When to use Sync Clients

Sync clients are the right choice when:

- data comes from a server
- data can change outside your app
- multiple components use the same remote data
- caching and refetching matter
- you want less boilerplate

### Rule of thumb

> If the source of truth is the server → use a sync client.

---

## When NOT to use Sync Clients

Do not use sync clients for:

- local UI state
- form inputs
- toggles and animations
- temporary UI selections

That is still client state.

---

## Sync Clients vs Redux / Context

### Key difference

- Redux / Context → own the state
- Sync clients → mirror server state

You usually do not put server data into Redux.

---

## How tools fit together

A typical modern React app uses:

- useState → local UI state
- Context → shared UI data
- Redux / Zustand → complex client state (if needed)
- React Query / RTK Query → server data

They complement, not replace, each other.

---

## Common mistakes

- storing server data in Redux
- duplicating server data into Context
- manually managing loading states
- treating server data like UI state
- mixing concerns without a clear plan

---

## Mental model (easy to remember)

- Local state → UI behavior
- Context → shared access
- Redux → client-owned complex state
- Sync clients → server-owned data

Server state is not yours - you sync with it.

---

## Summary

- Sync clients manage server state
- They handle fetching, caching, and updates
- They reduce boilerplate dramatically
- They should not replace local or UI state
- Most modern apps benefit from them
- Prefer React Query or RTK Query today

# 4.05 Compound Components

Compound Components is a **component design pattern** where
multiple components work together and **share state implicitly**.

This pattern is often used to build **flexible, declarative APIs**
that feel natural to use in JSX.

---

## What Compound Components are

Compound Components are:

- a **parent component** that owns state and logic
- **child components** that consume that shared state
- components designed to be used **together**

They usually rely on **Context** under the hood.

The key idea:

> Components don’t receive props directly -  
> they get what they need from shared context.

---

## Context in simple words

Compound Components answer this question:

> How can I let users compose UI freely  
> while keeping logic in one place?

Instead of passing props like this:

```jsx
<Tabs activeTab={tab} onChange={setTab} />
```

You write:

```jsx
<Tabs>
  <Tabs.List>
    <Tabs.Trigger value="one" />
    <Tabs.Trigger value="two" />
  </Tabs.List>
  <Tabs.Content value="one" />
  <Tabs.Content value="two" />
</Tabs>
```

The structure describes intent, not data wiring.

---

## Basic mental model

- Parent → owns state and logic
- Children → read shared state
- Context → connects them

Think:

> “These components belong together.”

---

## Simple example (conceptual)

```jsx
function Tabs({ children }) {
  const [active, setActive] = useState(null);

  return (
    <TabsContext.Provider value={{ active, setActive }}>
      {children}
    </TabsContext.Provider>
  );
}
```

### Child components read from context

```jsx
function Tab({ value }) {
  const { active, setActive } = useContext(TabsContext);

  return <button onClick={() => setActive(value)}>{value}</button>;
}
```

The user never passes `active` manually.

---

## Why this feels nice to use

From the outside:

- no prop drilling
- clean JSX
- components read naturally
- structure matches meaning

The consumer focuses on **layout**, not wiring.

---

## What Compound Components are good at

Compound Components are useful for:

- highly reusable UI components
- flexible layouts
- APIs where structure matters more than props

Common real-world examples:

- Tabs
- Accordions
- Menus / Dropdowns
- Modals
- Tooltips

Libraries like **Radix UI** use this pattern heavily.

---

## What Compound Components do NOT do

Compound Components:

- do not replace state management
- do not magically optimise performance
- do not remove re-renders
- do not work well without shared context

They are a **composition pattern**, not a feature.

---

## Compound Components vs Props

With props:

- explicit
- predictable
- easy to trace

With compound components:

- implicit
- more flexible
- cleaner JSX
- harder to debug internally

Both are valid - choose based on use case.

---

## Compound Components vs Hooks

Hooks:

- share logic
- do not define structure

Compound Components:

- define structure
- control how components fit together

Often used together.

---

## When to use Compound Components

Use them when:

- components must be used together
- you want a clean, declarative API
- layout flexibility is important
- prop drilling would be ugly

---

## When NOT to use them

Avoid them when:

- the component is simple
- props are clearer
- logic is minimal
- debugging simplicity matters more than API elegance

If props are clear → **use props**.

---

## Common mistakes

- overusing compound components for simple UI
- hiding too much logic in context
- making components tightly coupled
- unclear error messages when used incorrectly

Compound Components require **good documentation**.

> It’s common to throw an error if a compound child is used outside its parent
> (e.g. useTabsContext called without a provider).

---

## Mental model (easy to remember)

- Parent → owns logic
- Children → consume shared state
- Context → glue
- JSX structure → API

Compound Components = **components that cooperate**.

---

## Summary

- Compound Components are a design pattern
- They use Context to share state implicitly
- They create flexible, declarative APIs
- They are great for reusable UI libraries
- They add indirection and complexity
- Use them intentionally, not by default

# 4.02 Render Props

Render Props is a **pattern for reusing logic** between components.

It means:

- a component receives a **function as a prop**
- that function returns JSX
- the component calls that function to decide what to render

This pattern was common **before React Hooks**.

---

## Render Props in simple words

Render Props answers this question:

> How can I share the same logic across components  
> but let each place control the UI?

So:

- the logic lives in one component
- the UI is decided by the parent via a function

---

## The key idea

A “render prop” is usually a prop named:

- `render`
- or `children` (when children is a function)

Example shape:

```jsx
<SomeComponent render={(data) => <div>{data}</div>} />
```

or

```jsx
<SomeComponent>{(data) => <div>{data}</div>}</SomeComponent>
```

---

## Example (conceptual): sharing mouse position logic

```jsx
function MouseTracker({ render }) {
  const [position, setPosition] = useState({ x: 0, y: 0 });

  function handleMove(e) {
    setPosition({ x: e.clientX, y: e.clientY });
  }

  return <div onMouseMove={handleMove}>{render(position)}</div>;
}
```

Usage:

```jsx
<MouseTracker
  render={(pos) => (
    <p>
      Mouse: {pos.x}, {pos.y}
    </p>
  )}
/>
```

Here:

- `MouseTracker` owns the logic (tracking mouse position)
- the parent decides how to render it (paragraph, tooltip, etc.)

---

## Using `children` as a function (common)

Some libraries use this style:

```jsx
function DataLoader({ children }) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch("/api/data")
      .then((r) => r.json())
      .then(setData);
  }, []);

  return children(data);
}
```

Usage:

```jsx
<DataLoader>
  {(data) => (data ? <div>{data.name}</div> : <div>Loading…</div>)}
</DataLoader>
```

---

## What Render Props are good at

Render Props are useful for:

- reusing logic across many components
- giving full control over UI to the consumer
- building reusable “logic components”

Common historical use cases:

- data fetching
- mouse / scroll tracking
- form helpers
- animations
- reusable component behavior

---

## What Render Props do NOT do

Render Props:

- do not replace state management
- do not remove re-renders
- do not make logic automatically “shared” (it’s still per instance)

It is just a pattern:

> pass a function → component calls it

---

## Render Props vs Hooks

Before Hooks:

- Render Props were a main way to reuse logic

After Hooks:

- hooks are usually simpler
- logic can be extracted into a custom hook
- UI stays cleaner (less nesting)

Today:

> Prefer hooks for new code.  
> Render Props still exist in older codebases and libraries.

---

## Problems with Render Props

Common downsides:

- extra nesting in JSX (can look messy)
- harder to follow component tree
- can become “wrapper hell” if overused

Example nesting:

```jsx
<DataLoader>
  {(data) => (
    <MouseTracker
      render={(pos) => (
        <div>
          {data.name} at {pos.x},{pos.y}
        </div>
      )}
    />
  )}
</DataLoader>
```

This becomes harder to read.

---

## When to use Render Props today

Render Props still make sense when:

- working with older codebases
- using third-party libraries that expose render-prop APIs
- you need maximum UI flexibility from a reusable logic component

But for new logic:

> Prefer custom hooks and composition.

---

## Mental model

- Component → owns logic
- Render prop function → decides UI
- Result → reusable logic + flexible rendering

Render Props = **“logic component + function that renders UI”**

---

## Summary

- Render Props is a pattern for sharing logic
- You pass a function that returns JSX
- The component calls it to render UI
- It was common before hooks
- Hooks are usually preferred today
- Still useful to understand for legacy code and interviews (!)

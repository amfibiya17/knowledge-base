# 4.04 React.memo and Memoisation Strategy

This section explains how React **re-renders components**
and how memoisation can help **avoid unnecessary re-renders**.

This is about **render optimisation**, not state management.

---

## Why re-renders happen

In React:

- when **state changes**
- when **props change**
- when a **parent re-renders**

> → the component **re-renders**

Important rule:

> When a parent re-renders, **all children re-render by default** (unless memoised).

Even if their props did not change.

---

## What `React.memo` is

`React.memo` is a **higher-order component** that:

- wraps a component
- remembers its previous props
- skips re-rendering if props are the same

It is a **performance optimisation**, not a requirement.

Custom comparison (rare) → React.memo can take a custom comparison function:

```js
React.memo(Component, areEqual)
```
---

## Basic syntax

```jsx
const MemoComponent = React.memo(Component);
```

Or inline:

```jsx
const Button = React.memo(function Button({ label }) {
  return <button>{label}</button>;
});
```

Here:

- React compares old props and new props
- if they are shallowly equal, React skips the render

## Basic example

```jsx
const Child = React.memo(function Child({ value }) {
  console.log("Child rendered");
  return <div>{value}</div>;
});

function Parent() {
  const [count, setCount] = useState(0);

  return (
    <>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <Child value="Hello" />
    </>
  );
}
```

Here:

- Parent re-renders when count changes
- Child does NOT re-render
- because value="Hello" did not change

---

## How React.memo works (important)

React.memo uses shallow comparison of props.

That means:

- primitives → compared by value
- objects / arrays / functions → compared by reference

Example:

```jsx
<Child options={{ a: 1 }} />
```

This creates a new object on every render → re-render happens.

Note: React.memo does not prevent re-renders caused by context changes.

---

## When React.memo helps

React.memo is useful when:

- a component re-renders often
- props usually stay the same
- the component is expensive to render
- it is part of a large list or tree

Common use cases:

- list items
- buttons
- pure presentational components
- components far down the tree

---

## When React.memo does NOT help

React.memo is useless or harmful when:

- props change on every render
- props include inline objects or functions
- the component is cheap to render
- you use it everywhere “just in case”

If props always change → memo does nothing.

---

## React.memo vs useMemo vs useCallback

### React.memo

- memoises a component
- skips re-render if props are equal

### useMemo

- memoises a value
- avoids re-computing expensive calculations

### useCallback

- memoises a function
- keeps function reference stable

They are often used together.

---

## Common mistake: memo without stable props

```jsx
const Child = React.memo(({ onClick }) => {
  return <button onClick={onClick}>Click</button>;
});

function Parent() {
  return <Child onClick={() => console.log("hi")} />;
}
```

This still re-renders, because `() => console.log("hi")` is a new function on every render.

### Fix

```jsx
const onClick = useCallback(() => {
  console.log("hi");
}, []);
```

---

## Memoisation strategy (rule of thumb)

Do **NOT** memoise everything.

Start with:

- clean component structure
- clear state ownership

Only add memoisation when:

- you measure performance problems
- re-renders are frequent
- rendering is expensive

---

## Common mistakes

- wrapping every component in `React.memo`
- using memo without understanding prop references
- using memo instead of fixing state structure
- assuming memo prevents all re-renders

Memoisation is a tool, not a fix-all.

---

## Mental model

- State change → re-render
- Parent re-render → children re-render
- React.memo → “Skip render if props didn’t change”
- useMemo → “Reuse computed value”
- useCallback → “Reuse function reference”

---

## Summary

- React.memo prevents unnecessary re-renders
- It works by comparing props (shallowly)
- It is a performance optimisation
- It does not prevent all re-renders
- It works best with stable props
- Use it intentionally, not everywhere

# 7.09 CI / CD Integration

**CI/CD** stands for **Continuous Integration** and **Continuous Delivery / Deployment**.

It is the practice of **automating checks and deployments**
so code changes are **safe, repeatable, and fast**.

In modern frontend teams, CI/CD is **essential**, not optional.

---

## What CI and CD mean

### Continuous Integration (CI)

CI means:

- every code change is integrated frequently
- code is automatically checked
- problems are caught early

Typical CI tasks:

- install dependencies
- run linting
- run unit tests
- run type checks
- build the project

CI answers:

> “Is this code safe to merge?”

---

### Continuous Delivery / Deployment (CD)

CD means:

- code is automatically prepared for release
- deployments are consistent and repeatable

Two flavours:

- **Continuous Delivery** → code is always deployable; release is triggered manually
- **Continuous Deployment** → every successful change is deployed automatically

CD answers:

> “Can we safely release this code?”

---

## Why CI/CD matters for frontend

Without CI/CD:

- bugs reach production easily
- builds break unexpectedly
- team members overwrite each other
- releases are stressful and manual

With CI/CD:

- confidence in every change
- consistent quality
- faster feedback
- safer releases

CI/CD protects the **entire team**, not just individuals.

---

## Typical frontend CI pipeline

A common CI pipeline looks like:

1. Pull Request opened
2. CI pipeline runs automatically
3. Checks must pass before merge

Typical steps:

```text
Install → Lint → Type check → Test → Build
```

If any step fails → merge is blocked.

---

## Common CI checks in frontend projects

### Linting

- ESLint
- Stylelint

Catches:

- code smells
- formatting issues
- common bugs

---

### Type checking

- TypeScript (`tsc --noEmit`)

Catches:

- invalid props
- incorrect types
- unsafe logic

This prevents many runtime errors.

---

### Unit tests

- Jest
- Vitest
- Testing Library

Ensures:

- components behave correctly
- logic changes don’t break features

---

### Build step

- `npm run build`

Ensures:

- the app actually compiles
- no missing imports
- no build-time errors

Never skip the build step.

---

## CD in frontend projects

CD usually handles:

- preview deployments
- staging deployments
- production deployments

Common flow:

- PR → preview environment
- merge to main → staging
- release → production

This allows:

- QA to test changes
- designers to review UI
- stakeholders to see features early

---

## Common CI/CD tools

Popular CI/CD platforms:

- **GitHub Actions**
- **GitLab CI**
- **CircleCI**
- **Azure DevOps**
- **Bitbucket Pipelines**

Popular hosting / deployment platforms:

- **Vercel**
- **Netlify**
- **Cloudflare Pages**
- **AWS / Azure**

---

## CI/CD and pull requests

CI is usually tied to **Pull Requests**.

Best practices:

- no merge without green CI
- small PRs
- fast feedback (< 10 minutes)
- clear failure messages

---

## CI/CD for quality, not punishment

CI/CD is not about:

- blocking developers
- enforcing rules blindly

It is about:

- catching mistakes early
- protecting production
- reducing human error

CI/CD should feel like a **safety net**.

---

## Common mistakes

- skipping tests “to save time”
- disabling failing checks instead of fixing them
- running too many slow checks
- unclear CI failure messages
- deploying without verification

Bad CI creates frustration.
Good CI creates trust.

---

## Mental model

- CI → “Is this change safe?”
- CD → “Can this be released?”
- Automation → consistency

---

## Summary

- CI/CD automates testing and deployment
- CI checks code quality on every change
- CD automates release processes
- Essential for modern frontend teams
- Prevents bugs and broken releases
- CI/CD is a safety net, not a blocker
- Good pipelines enable faster, safer development

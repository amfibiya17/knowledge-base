# 7.02 Unit Testing

**Unit testing** is the practice of testing **small, isolated pieces of code**
to ensure they behave correctly.

A “unit” is usually:

- a function
- a hook
- a utility
- a small component with limited logic

Unit tests focus on **correctness**, not visuals.

---

## Why unit testing matters

Unit tests help you:

- catch bugs early
- prevent regressions
- refactor with confidence
- document expected behaviour
- reduce fear of change

Without tests:

- small changes break unrelated features
- bugs are found late (or in production)
- refactoring feels risky

Unit tests act as a **safety net**.

---

## What unit tests are (and are not)

### Unit tests ARE:

- fast
- deterministic
- isolated
- focused on logic

### Unit tests are NOT:

- full app tests
- visual tests
- browser behaviour tests
- end-to-end flows

They test **one thing at a time**.

---

## Common unit testing tools (React ecosystem)

Most React projects use:

- **Jest** or **Vitest** → test runner
- **Testing Library** → test utilities
- **@testing-library/react** → component testing

Vitest is increasingly popular in modern setups.

---

## A simple unit test example

Testing a pure function:

```ts
function add(a: number, b: number) {
  return a + b;
}
```

Test:

```ts
test("adds two numbers", () => {
  expect(add(2, 3)).toBe(5);
});
```

This test checks:

- input
- output
- nothing else

---

## Testing React components (basic example)

```tsx
import { render, screen } from "@testing-library/react";
import Button from "./Button";

test("renders button text", () => {
  render(<Button>Click me</Button>);

  expect(screen.getByText("Click me")).toBeInTheDocument();
});
```

Key ideas:

- render the component
- query what the user would see
- assert expected behaviour

---

## Testing behaviour, not implementation

Good tests focus on **what the user sees or does**.

Bad test (implementation detail):

```ts
expect(component.state.isOpen).toBe(true);
```

Good test (behaviour):

```ts
expect(screen.getByText("Menu")).toBeVisible();
```

This makes tests:

- more resilient
- easier to refactor
- closer to real usage

---

## Testing user interactions

Use user events, not internal methods.

```ts
import userEvent from "@testing-library/user-event";

test("calls onClick when clicked", async () => {
  const user = userEvent.setup();
  const onClick = vi.fn();

  render(<Button onClick={onClick}>Click</Button>);

  await user.click(screen.getByText("Click"));

  expect(onClick).toHaveBeenCalled();
});
```

This simulates **real user behaviour**.

---

## Mocking (important concept)

Mocks replace real dependencies with fake ones.

Used when:

- calling APIs
- using timers
- depending on external services

Example:

```ts
vi.fn();
```

`vi.fn()` in Vitest, `jest.fn()` in Jest.

Mocks help keep tests:

- fast
- isolated
- predictable

But over-mocking makes tests fragile.

---

## What to mock (rule of thumb)

Mock:

- network requests
- browser APIs
- expensive operations
- third-party services

Do NOT mock:

- the thing you are testing
- simple logic
- your own utilities (usually)

Test real logic whenever possible.

---

## Testing hooks

Hooks are tested using `renderHook` from `@testing-library/react`.

Example idea:

```ts
const { result } = renderHook(() => useCounter());

expect(result.current.count).toBe(0);
```

Hooks are great unit-test targets because they contain logic.

---

## What NOT to unit test

Avoid unit testing:

- CSS
- layout details
- implementation details
- third-party libraries
- trivial getters/setters

Test **behaviour and logic**, not everything.

---

## Unit tests vs other test types

**Unit tests**

- fast
- isolated
- logic-focused

**Integration tests**

- multiple units together
- more realistic
- slower

**E2E tests**

- full user flows
- browser-based
- slowest but most realistic

All have value, but unit tests are the **foundation**.

---

## Common mistakes

- testing implementation instead of behaviour
- over-mocking everything
- fragile tests tied to internal structure
- slow tests
- skipping tests “for now”

Bad tests are worse than no tests.

---

## Mental model

- Unit test → one piece of logic
- Input → action
- Output → assertion
- Fast → runs often
- Reliable → same result every time

Think:

> “If this breaks, do I want to know immediately?”

---

## Summary

- Unit tests verify small pieces of logic
- They are fast and isolated
- Focus on behaviour, not implementation
- Testing Library encourages user-centric tests
- Mocks should be used carefully
- Unit tests are the base of a healthy test strategy
- They increase confidence and reduce regressions

# 7.03 TypeScript

**TypeScript** is a superset of JavaScript that adds **static typing**.

It helps you catch errors **before code runs**
and makes large codebases **safer and easier to maintain**.

TypeScript does not change how JavaScript works.
It adds **guarantees and tooling** on top of it.

---

## Why TypeScript exists

JavaScript is:

- dynamic
- flexible
- fast to write

But in large apps, this leads to:

- runtime errors
- unclear data shapes
- fragile refactors
- fear of change

TypeScript solves this by:

- checking code at compile time
- making assumptions explicit
- documenting intent through types

---

## What TypeScript gives you

TypeScript provides:

- static type checking
- better autocomplete
- safer refactoring
- clearer APIs
- fewer runtime bugs

Most errors are caught **in your editor**, not in production.

---

## Basic example

JavaScript:

```js
function add(a, b) {
  return a + b;
}
```

TypeScript:

```ts
function add(a: number, b: number): number {
  return a + b;
}
```

Now TypeScript can:

- prevent passing strings
- warn about wrong usage
- help during refactors

---

## Types describe shapes

Types describe **what data looks like**.

```ts
type User = {
  id: string;
  name: string;
  isAdmin: boolean;
};
```

This makes data contracts explicit.

If something changes, TypeScript tells you **where it breaks**.

---

## Interfaces vs types (simple rule)

Both describe shapes.

```ts
interface User {
  id: string;
  name: string;
}
```

```ts
type User = {
  id: string;
  name: string;
};
```

Rule of thumb:

- `type` → most use cases
- `interface` → when extension / declaration merging is needed

Do not overthink this early on.

---

## Type inference (very important)

TypeScript often figures types out for you.

```ts
const count = 0; // number
const name = "Alex"; // string
```

You don’t need to annotate everything.

Good TypeScript is:

> explicit where needed, inferred where possible.

---

## Union types (powerful feature)

Union types allow **multiple valid values**.

```ts
type Status = "loading" | "success" | "error";
```

This prevents invalid values at compile time.

```ts
if (status === "loading") {
  // safe
}
```

Impossible states become impossible to represent.

---

## Optional properties

```ts
type User = {
  id: string;
  name?: string;
};
```

Optional does **not** mean always present.

TypeScript forces you to handle `undefined`.

---

## `any` vs `unknown` (important)

### `any`

- disables type checking
- unsafe
- avoid when possible

```ts
let value: any;
```

### `unknown`

- safe alternative
- forces you to check before using

```ts
let value: unknown;
```

Rule:

> Prefer `unknown` over `any` (!)

---

## TypeScript in React

TypeScript shines in React.

Example props typing:

```tsx
type ButtonProps = {
  onClick: () => void;
  children: React.ReactNode;
};

function Button({ onClick, children }: ButtonProps) {
  return <button onClick={onClick}>{children}</button>;
}
```

This ensures:

- correct props usage
- safer component reuse
- better autocomplete

---

## TypeScript with hooks (example)

```ts
const [count, setCount] = useState<number>(0);
```

> Generic annotation is only needed when the initial value is null or ambiguous.

Often you don’t even need the annotation:

```ts
const [count, setCount] = useState(0);
```

TypeScript infers it.

---

## Generics

Generics let you write code that works with **any type**
while keeping **full type safety**.

They use a placeholder (usually `T`) to mean: “The type will be provided later.”

---

### Basic example

```ts
function identity<T>(value: T): T {
  return value;
}
```

This means:

- whatever type goes **in**
- the **same type** comes **out**

Examples:

```ts
identity(5); // number
identity("hello"); // string
identity({ id: 1 }); // { id: number }
```

No type information is lost.

---

### Why generics are useful

Without generics:

```ts
function identity(value: any) {
  return value;
}
```

Problems:

- no type safety
- no autocomplete
- easy to make mistakes

Generics solve this by:

- avoiding `any`
- keeping exact types
- making code reusable **and safe**

---

### Where generics are commonly used

Generics are heavily used in:

- hooks (e.g. `useState<T>`)
- utilities (e.g. helpers, mappers)
- libraries (must work with many data shapes)

```ts
const [count, setCount] = useState<number>(0);
```

---

## Common TypeScript mistakes

- overusing `any`
- typing everything manually
- ignoring compiler errors
- fighting the type system
- using types instead of fixing logic

TypeScript should **guide you**, not slow you down.

---

## Mental model

- JavaScript → runtime behaviour
- TypeScript → compile-time safety
- Types → documentation + constraints
- Compiler → your safety net

---

## Summary

- TypeScript adds static typing to JavaScript
- Errors are caught before runtime
- It improves refactoring and confidence
- Type inference reduces boilerplate
- Avoid `any`, prefer explicit types when needed
- Excellent fit for React and modern apps
- A core tool for professional frontend development

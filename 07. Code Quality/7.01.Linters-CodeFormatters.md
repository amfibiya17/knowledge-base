# 7.01 Linters & Code Formatters

**Linters** and **code formatters** are tools that help keep code
**clean, consistent, and correct** across a team.

They are a core part of **code quality** in modern frontend projects.

---

## Why code quality tools matter

As projects grow:

- multiple developers write code
- styles drift
- small mistakes slip in
- reviews focus on formatting instead of logic

Linters and formatters solve this by:

- automating consistency
- catching mistakes early
- reducing review noise
- enforcing shared standards

They help teams **argue less and ship more**.

---

## Linters vs Code Formatters

They solve **different problems**.

### Linters

Linters focus on **code correctness and best practices**.

They answer questions like:

- Is this code safe?
- Is this a bug?
- Is this pattern discouraged?
- Is this variable unused?

Example tools:

- **ESLint** (JavaScript / TypeScript)
- **Stylelint** (CSS)

---

## Code formatters

Formatters focus on **how code looks**.

They answer questions like:

- How many spaces?
- Single or double quotes?
- Line length?
- Where to break lines?

Example tool:

- **Prettier**

Formatters do **not** care about logic.

---

## ESLint (most important linter)

**ESLint** is the standard linter for JS/TS projects.

It helps catch:

- unused variables
- missing dependencies in hooks
- accidental globals
- unsafe patterns
- common bugs

Example ESLint warning:

```ts
const x = 5; // defined but never used
```

This is a **real bug signal**, not style.

---

## TypeScript + ESLint (powerful combo)

When used together:

- TypeScript checks **types**
- ESLint checks **logic and patterns**

Example:

- TypeScript → “wrong type”
- ESLint → “bad hook usage”

Together they catch most mistakes **before runtime**.

---

## Prettier (code formatter)

**Prettier** formats code automatically.

Example input:

```js
// prettier-ignore
const add=(a,b)=>{return a+b}
```

After Prettier:

```js
const add = (a, b) => {
  return a + b;
};
```

Benefits:

- no style debates
- consistent formatting
- faster reviews
- less mental load

---

## Linting vs formatting (important rule)

> **Never use ESLint for formatting if you use Prettier.**

Best practice:

- ESLint → correctness
- Prettier → formatting

They should **not fight each other**.

---

## Common ESLint rules (examples)

Some important rules:

- `no-unused-vars`
- `no-console` (often relaxed)
- `react-hooks/exhaustive-deps`
- `@typescript-eslint/no-explicit-any`
- `eqeqeq`

These rules prevent **real bugs**.

---

## Auto-fixing (huge productivity boost)

Both ESLint and Prettier can **auto-fix** issues.

Example:

```bash
npm run lint -- --fix
```

Or automatically on save in your editor.

This turns rules into **helpers**, not punishments.

---

## Editor integration (very important)

Linters and formatters work best when:

- errors show in the editor
- formatting happens on save
- feedback is immediate

Most teams configure:

- format on save
- lint warnings inline
- CI checks as backup

---

## Linting in CI (non-negotiable)

Linters should run in **CI pipelines** (!)

Why:

- prevents broken code merging
- enforces standards consistently
- removes “works on my machine”

If lint fails → PR should fail.

---

## When rules become harmful

Bad lint setups:

- too many rules
- unclear errors
- rules nobody understands
- rules constantly disabled

Good rules:

- catch bugs
- reflect team agreement
- are documented
- are enforced consistently

---

## Common mistakes

- using ESLint only for formatting
- ignoring lint errors instead of fixing them
- disabling rules without understanding them
- not running lint in CI
- inconsistent editor setup across team

---

## Mental model

- TypeScript → types
- tsconfig → type strictness
- ESLint → logic & correctness
- Prettier → formatting
- CI → enforcement

Think:

> “Tools should help me write better code,
> not slow me down.”

---

## Summary

- Linters and formatters are core code quality tools
- ESLint finds bugs and bad patterns
- Prettier enforces consistent formatting
- They solve different problems
- Auto-fix and editor integration are essential
- CI enforcement keeps standards consistent
- Good rules improve code, bad rules create friction

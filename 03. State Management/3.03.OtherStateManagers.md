# 3.03 Other State Managers

This section covers **alternative client-side state management libraries**
such as **MobX, Zustand, Nanostores, Jotai**, and others.

These tools are **alternatives to Redux**.
They solve the same problem - managing shared state -
but use **different mental models** and trade-offs.

---

## What “other state managers” means

Other state managers are libraries that:

- store shared state outside React components
- allow many components to read and update that state
- reduce boilerplate compared to Redux
- often feel simpler or more flexible

They are mostly used for **client-side shared state**.

They do **not** replace:

- Context (data delivery)
- server state tools (React Query, RTK Query)

---

## Why alternatives exist

Redux is powerful, but:

- you have to write a lot of code to do simple things
- it requires more structure
- It takes more time and effort to understand and use it confidently

Many teams prefer simpler tools when:

- the app is small or medium-sized
- state logic is not very complex
- fast development matters
- fewer developers are involved

---

## MobX

### What MobX is

MobX is a **reactive state management library**.

Instead of actions and reducers:

- state is mutable (you can change the state directly, instead of creating a new copy)
- changes are tracked automatically
- components re-render when the data they use changes

---

### Mental model

> Change the data, and the UI reacts automatically.

MobX is based on **observables** (tracks which data is used, and automatically reacts when that data changes).

---

### Example idea (conceptual)

```js
store.count++;
```

When `count` changes:

- any component using `count` updates automatically
- no explicit actions or reducers are required

MobX tracks which data a component uses and reacts to changes automatically.

---

### When MobX works well

MobX is a good fit when:

- you want minimal boilerplate
- state relationships are complex
- you prefer reactive programming (the system automatically reacts to data changes)
- you want very fast iteration

---

### Trade-offs

- less explicit than Redux
- harder to trace where changes come from
- debugging can be less predictable
- more “magic” under the hood

---

## Zustand

### What Zustand is

Zustand is a **small, hook-based global state library**.

It feels very close to React hooks.

---

### Mental model

> A global `useState` that any component can use.

---

### Example idea (conceptual)

```js
const useStore = create((set) => ({
  count: 0,
  increment: () => set((state) => ({ count: state.count + 1 })),
}));
```

Components call the hook to read and update state.

---

## When Zustand works well

Zustand is great when:

- you want very little boilerplate
- state is shared but not very complex
- you like hooks and simple APIs
- you don’t need heavy structure

---

## Trade-offs (Zustand)

- less strict structure
- easier to misuse in large apps
- fewer built-in conventions than Redux

---

## Nanostores

### What Nanostores is

Nanostores is a **tiny, atomic state management library**.

It focuses on:

- very small stores
- explicit subscriptions
- framework-agnostic design

---

### Mental model

> Many small stores instead of one big store.

---

### Example idea (conceptual)

```js
const count = atom(0);
count.set(count.get() + 1);
```

Components subscribe only to what they need.

---

## When Nanostores works well

Nanostores is useful when:

- performance matters
- you want very small bundles
- state should be isolated
- you prefer explicit data flow

---

## Trade-offs (Nanostores)

- less common in large teams
- fewer patterns and conventions
- smaller ecosystem

---

## Jotai

### What Jotai is

Jotai is an **atom-based state management library**.

State is split into small independent units called **atoms**.

---

### Mental model

> State is made of tiny pieces, not one big object.

---

### Example idea (conceptual)

```js
const countAtom = atom(0);
```

Components read and update atoms directly.

---

## When Jotai works well

Jotai is a good choice when:

- state can be naturally split into small pieces
- you want minimal setup
- you want fine-grained updates
- you prefer a functional style

---

## Trade-offs (Jotai)

- harder to understand state flow at scale
- atom relationships can become unclear
- less explicit than Redux

---

## Recoil (brief note)

Recoil is another atom-based state library.

It introduced useful ideas, but:

- adoption slowed
- ecosystem is smaller
- many teams now prefer Jotai or Zustand

Still worth knowing, but less common today.

---

## Context vs Redux vs Other State Managers

### Simple comparison

- **Context** → sharing data, not managing logic
- **Redux / RTK** → structured, explicit state management
- **MobX** → reactive, implicit updates
- **Zustand / Jotai / Nanostores** → minimal, flexible state

---

## How to choose (rule of thumb)

- Start with **local state**
- Use **Context** for simple shared data
- Use **Redux / RTK** for complex, large-scale apps
- Use **Zustand / Jotai / MobX** when Redux feels too heavy

There is no single “best” choice.

---

## Common mistakes

- choosing a library before understanding the problem
- mixing many state managers without a clear reason
- using global state when local state is enough
- assuming “simpler” means “better for everything”

---

## Mental model

- Local state → component-level
- Context → shared access
- Redux → predictable structure
- Other state managers → flexibility and speed

---

## State management comparison

| Tool                       | Best used for               | Strengths                                  | Trade-offs                | When to choose it                     |
| -------------------------- | --------------------------- | ------------------------------------------ | ------------------------- | ------------------------------------- |
| Local state (`useState`)   | State used by one component | Simple, explicit, easy to reason about     | Not shareable             | Default choice for UI state           |
| Context                    | Shared app-level data       | Built-in, avoids prop drilling             | Re-renders all consumers  | Theme, user, language                 |
| Redux / RTK                | Complex shared state        | Predictable, explicit, great tooling       | More boilerplate          | Large apps, complex logic             |
| MobX                       | Reactive state              | Very little boilerplate, automatic updates | Implicit, harder to debug | Complex relationships, fast iteration |
| Zustand                    | Simple global state         | Minimal API, hook-based, flexible          | Less structure            | Small–medium apps                     |
| Jotai                      | Atom-based state            | Fine-grained updates, minimal setup        | Can get unclear at scale  | State split into small pieces         |
| Nanostores                 | Tiny isolated state         | Very small bundles, explicit subscriptions | Smaller ecosystem         | Performance-critical apps             |
| Server state (React Query) | API data                    | Caching, syncing, background updates       | Not for UI state          | Data from backend APIs                |

---

## Summary

- Other state managers are alternatives to Redux
- They manage shared client-side state
- They trade structure for simplicity
- Each has a different mental model
- Choice depends on app size, team, and complexity
- Prefer clarity over trends

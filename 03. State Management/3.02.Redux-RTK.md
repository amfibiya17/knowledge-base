# 3.02 Redux / Redux Toolkit (RTK)

Redux is a **state management library** used to manage shared application state
in a predictable way.

Redux Toolkit (RTK) is the **recommended modern way** to write Redux.
It reduces boilerplate and makes Redux easier to use correctly.

---

## What Redux is

Redux is a place where you keep **shared app state** in one central store.

Components can:

- **read** state from the store
- **dispatch actions** to update state

Redux helps when state becomes hard to manage with just props and context.

---

## What problem Redux solves

Redux is useful when:

- many parts of the app need the same state
- updates happen from many places
- state changes must be predictable and easy to debug
- the app is large and state logic is complex

Redux makes state updates **structured** and **traceable**.

---

## How Redux works

Redux follows a clear flow:

1. UI dispatches an **action** (what happened)
2. reducers update state based on that action (how state changes)
3. the store produces the new state
4. UI re-renders based on the new state

A key idea:

> State changes happen through actions and reducers, not directly.

---

## Key terms

- **Store**: the object that holds the whole Redux state
- **Action**: a plain object describing what happened (e.g. `{ type: "cart/add" }`)
- **Reducer**: a function that returns the next state
- **Dispatch**: the function used to send actions to the store
- **Selector**: a function that reads a value from the store

---

## Redux vs Context

Context:

- good for sharing app-level data
- best when values change infrequently
- simple and built-in

Redux:

- good for complex, shared state
- handles frequent updates better
- has strong tooling and debugging support

Rule of thumb:

> Use Context for simple shared state.  
> Use Redux when shared state becomes complex or hard to track.

---

## Why Redux is predictable

Redux encourages good structure:

- state is updated in one consistent way (actions → reducers)
- reducers are pure functions
- updates are easier to test
- debugging is easier because changes are explicit

---

## What Redux Toolkit (RTK) is

Redux Toolkit is the official recommended way to write Redux.

RTK gives you:

- less boilerplate
- good defaults
- built-in tools to reduce common mistakes

RTK is what most people mean today when they say “Redux”.

---

## RTK building blocks

Redux Toolkit commonly uses:

- `configureStore()` → sets up the store with good defaults
- `createSlice()` → creates reducers + actions in one place
- `createAsyncThunk()` → handles async logic (usually API calls)

---

## Example: slice

A slice groups state + reducers + actions.

```js
import { createSlice } from "@reduxjs/toolkit";

const counterSlice = createSlice({
  name: "counter",
  initialState: { value: 0 },
  reducers: {
    increment(state) {
      state.value += 1;
    },
    decrement(state) {
      state.value -= 1;
    },
  },
});

export const { increment, decrement } = counterSlice.actions;
export default counterSlice.reducer;
```

Here:

- reducers describe how state changes
- Redux Toolkit uses **Immer**, so “mutating” code inside reducers is safe
- under the hood, Redux still produces **immutable updates**

---

## Example: store setup

```js
import { configureStore } from "@reduxjs/toolkit";
import counterReducer from "./counterSlice";

export const store = configureStore({
  reducer: {
    counter: counterReducer,
  },
});
```

Here:

- `configureStore` sets up the Redux store with good defaults
- each key in `reducer` becomes a slice of the global state
- `counter` will be available as `state.counter`

---

## Example: using Redux in components

In React apps, components usually:

- read state using **selectors**
- dispatch **actions** in response to user events

(Exact code depends on the setup, but the idea stays the same)

---

## When Redux / RTK is a good choice

Redux / RTK fits well when:

- you have a lot of shared state across pages or features
- state transitions are complex
- updates happen frequently
- you need strong debugging tools and consistency
- multiple developers work on the same state

---

## When Redux is NOT needed

Redux may be unnecessary when:

- state is local to one component
- you only need to share state within a small subtree (Context works)
- the app is small and state is simple
- adding Redux would add more complexity than it removes

---

## Common mistakes

- using Redux for local component UI state
- putting everything into Redux “just in case”
- making reducers too large instead of splitting slices
- storing derived data instead of computing it in selectors
- mixing server state and UI state without a clear plan

---

## Mental model

- Context → simple shared data
- Redux / RTK → structured shared state with predictable updates
- Actions → what happened
- Reducers → how state changes
- Store → single source of truth for shared app state

---

## Summary

- Redux manages shared app state in a predictable way
- Redux Toolkit is the modern recommended way to use Redux
- Redux uses actions → reducers → new state
- Use Redux when shared state becomes complex or hard to track
- Prefer Context or local state when Redux is unnecessary

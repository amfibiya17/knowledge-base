# 3.01 Context

Context is a **pattern for sharing state** across many components
without passing props through every level of the component tree.

It is mainly used when some data is needed in many places,
and passing it down as props becomes messy.

Context uses React’s Context API (`createContext` and `useContext`)
to provide shared data such as user authentication or theme
to deeply nested components.

Context helps organise shared state,
but it does **not** manage complex state logic by itself.

It is often combined with reducers or other tools as apps grow.

---

## Context in simple words

Context helps you answer this question:

> How can many components access the same data
> without passing it through every parent?

Context lets components **read shared data directly**.

---

## The problem Context solves (prop drilling)

Without Context, data is passed like this:

```jsx
<App>
  <Layout>
    <Header>
      <UserMenu user={user} />
    </Header>
  </Layout>
</App>
```

Here:

- only `UserMenu` needs `user`
- but `Layout` and `Header` must receive and pass it
- those components don’t actually use the data

This is called **prop drilling**.

Context removes the need for this.

---

## What Context does

Context allows you to:

- store shared data in one place
- make it available to many components
- avoid passing props through components that don’t need them

Context is good for **shared app-level data**.

---

## What belongs in Context

Context works best for data that:

- is needed by many components
- represents app-level concerns
- does not change very often

Common examples:

- logged-in user
- theme (dark / light)
- language or locale
- feature flags
- app-wide settings

---

## What does NOT belong in Context

Avoid using Context for:

- form input values
- fast-changing UI state
- hover, focus, or animation state
- data used by only one component

If state is mostly local → **keep it local**.

---

## Context vs Props

Props are still the default choice.

- props are explicit
- props make data flow easy to follow
- props are easier to debug

Context is more powerful, but also easier to misuse.

Rule of thumb:

> Use props first.  
> Use Context only when prop drilling becomes a real problem.

---

## Where state lives when using Context

Context does not store state by itself.

Usually:

- state lives in a parent component
- Context exposes that state
- components read it using `useContext`

Context answers:

> Who can access the state?

It does not answer:

> How is the state updated?

---

## Context and state logic

Context is often combined with other tools:

- `useState` for simple state
- `useReducer` for complex state logic
- external stores (Redux, Zustand) for large apps

Context shares state.  
Other tools manage state.

---

## Performance notes

Important things to know:

- when context value changes, all consumers re-render
- large or frequently changing values can hurt performance

Because of this:

- keep context values small
- avoid putting fast-changing data into context
- split context if needed

---

## Common mistakes

- putting all app state into one context
- using context instead of props everywhere
- storing fast-changing UI state in context
- using context to avoid thinking about state ownership

Context should make things clearer, not hidden.

---

## Mental model

- State → owns the data
- Props → pass data directly
- Context → shared access to data
- Reducers / stores → handle complex logic

Context = **shared props for many components**.

---

## Summary

- Context is a pattern for sharing state
- It solves prop drilling
- Best for app-level, shared data
- It does not manage complex logic by itself
- State still needs a clear owner
- Use Context carefully and intentionally

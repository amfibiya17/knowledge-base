# 13.02 Function Examples

## Function declaration

**Use when:** you want a named function, hoisting, or classic JS style.

```ts
function add(a: number, b: number): number {
  return a + b;
}
```

---

## Function expression

**Use when:** you want to assign a function to a variable (and itâ€™s not hoisted like declarations).

```ts
const add = function (a: number, b: number): number {
  return a + b;
};
```

---

## Arrow function (most common)

**Use when:** callbacks, utilities, handlers, React code. Short and consistent.

```ts
const add = (a: number, b: number): number => a + b;
```

Block body (use when you need multiple lines):

```ts
const add = (a: number, b: number): number => {
  return a + b;
};
```

---

## No return (`void`)

**Use when:** the function performs an action (logging, saving, analytics), not returning a value.

```ts
function log(message: string): void {
  console.log(message);
}
```

```ts
const log = (message: string): void => {
  console.log(message);
};
```

---

## Default parameters

**Use when:** you want a fallback value if the argument is missing/undefined.

```ts
function greet(name: string = "Guest") {
  return `Hello ${name}`;
}
```

---

## Optional parameters

**Use when:** the argument might not be passed and you handle that case.

```ts
function greet(name?: string) {
  return name ? `Hello ${name}` : "Hello";
}
```

---

## Return object

**Use when:** you need to return structured data (multiple fields).

```ts
function createUser(name: string) {
  return {
    name,
    active: true,
  };
}
```

---

## Callback functions

**Use when:** you pass behaviour into another function (map, sort, timers, listeners).

```ts
[1, 2, 3].map((n) => n * 2);
```

```ts
setTimeout(() => {
  console.log("Done");
}, 1000);
```

---

## Functions as arguments

**Use when:** you want to control _when_ and _how_ something runs.

```ts
function run(fn: () => void) {
  fn();
}

run(() => console.log("Run"));
```

---

## Typed callbacks

**Use when:** you want TypeScript to enforce what the callback receives/returns.

```ts
function run(fn: (value: number) => number) {
  return fn(10);
}
```

---

## Async functions

**Use when:** working with promises (fetch, database, APIs).

```ts
async function fetchData() {
  const res = await fetch("/api");
  return res.json();
}
```

```ts
const fetchData = async () => {
  const res = await fetch("/api");
  return res.json();
};
```

---

## React-style handlers

**Use when:** handling events or updating state in React components.

```tsx
const handleClick = () => {
  setCount((c) => c + 1);
};
```

---

## Quick comparison

| Type        | Example                     | Use when                 |
| ----------- | --------------------------- | ------------------------ |
| Declaration | `function fn() {}`          | named + hoisting         |
| Expression  | `const fn = function () {}` | assign to variable       |
| Arrow       | `const fn = () => {}`       | callbacks/React/handlers |

---

## Rules of thumb

- Prefer **arrow functions** for callbacks, utilities, handlers, and React code
- Use **function declarations** for named functions and when hoisting is useful
- Keep functions small
- One responsibility per function
- Add return types when it improves clarity (especially for public/shared helpers)

# 2.6 useCallback

This file introduces the `useCallback` hook.  
`useCallback` is used to **memoise functions** so they are not recreated on every render.

---

## What `useCallback` is

`useCallback` is a React hook that:

- caches a function between renders
- returns the same function reference if dependencies do not change
- helps prevent unnecessary re-renders caused by changing function references

It is a **performance optimisation**, not required by default.

---

## Basic syntax

```jsx
const memoisedCallback = useCallback(() => {
  doSomething(a, b);
}, [a, b]);
```

Here:

- the function is memoised
- the dependency array controls when a new function is created
- the same function reference is reused between renders if dependencies don’t change

---

## Why functions matter in React

In React:

- functions are recreated on every render
- a new function means a new reference
- child components may re-render because props changed (even if logic didn’t)

This is where `useCallback` helps.

---

## Example: function passed to a child

```jsx
function Parent({ items }) {
  const handleClick = useCallback(() => {
    console.log(items.length);
  }, [items]);

  return <Child onClick={handleClick} />;
}
```

Here:

- `handleClick` keeps the same reference
- the function is recreated only when `items` changes
- `Child` does not re-render unnecessarily due to a new function prop (when the child is memoised)

---

## What happens when dependencies change

- component renders
- React compares dependency values
- if any dependency changed → new function is created
- function reference is cached
- component continues rendering

If dependencies do not change, the same function is reused.

---

## useCallback vs useMemo

useCallback is essentially a specialised form of useMemo.

These two are equivalent:

```jsx
useCallback(fn, deps);
```

```jsx
useMemo(() => fn, deps);
```

Difference:

- useMemo memoises values
- useCallback memoises functions

---

## Why `useCallback` exists

`useCallback` helps when:

- passing functions to memoised child components
- functions are dependencies of `useEffect`
- frequent re-renders cause unnecessary work
- performance issues are measurable

Without `useCallback`, function references change on every render.

---

## What `useCallback` does NOT do

- It does not prevent re-renders by itself
- It does not memoise component output
- It does not make code faster automatically
- It does not fix poor component structure

Using `useCallback` everywhere can hurt readability.

> If a function is not passed to another component or hook, `useCallback` is usually unnecessary.

---

## Common mistakes

- Using `useCallback` for functions that are not passed anywhere
- Forgetting dependencies
- Over-optimising without measuring
- Assuming it prevents all re-renders

If a function is cheap and local, **don’t memoise it**.

---

## Mental model

- Render → functions are recreated
- `useCallback` → “Can I reuse the old function?”
- Dependencies unchanged → reuse function
- Dependencies changed → create new function

`useCallback` trades memory for stable references.

---

## When to use `useCallback`

Use it when:

- a function is passed to a memoised child
- a function is a dependency of `useEffect`
- re-renders are caused by changing function references
- performance issues are confirmed

---

## Summary

- `useCallback` memoises functions
- It preserves function references between renders
- It re-creates functions only when dependencies change
- It is a performance optimisation
- It does not stop re-renders by default
- Use it intentionally, not everywhere
- Prefer clarity over premature optimisation

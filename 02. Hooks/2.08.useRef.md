# 2.8 useRef

This file introduces the `useRef` hook.  
`useRef` is used to **store mutable values** that persist across renders **without causing re-renders**.

`useRef` is for storing values React doesn’t need to re-render for.

---

## What `useRef` is

`useRef` is a React hook that returns a **mutable object** with a `.current` property.

It allows a component to:

- persist values across renders
- access DOM elements directly
- store mutable data without triggering re-renders

---

## Basic syntax

```jsx
const ref = useRef(initialValue);
```

Here:

- `ref` is an object: `{ current: initialValue }`
- `ref.current` can be read and updated
- updating `ref.current` does not cause a re-render

---

## useRef vs state (key difference)

- State updates → re-render
- Ref updates → **NO** re-render

This makes `useRef` useful for data that React does **not** need to display.

---

## Example: persisting a value across renders

```jsx
function Counter() {
  const renderCount = useRef(0);

  renderCount.current++;

  return <div>Renders: {renderCount.current}</div>;
}
```

Here:

- `renderCount.current` persists between renders
- updating it does not trigger another render
- the value survives re-renders

---

## Example: accessing DOM elements

```jsx
function InputFocus() {
  const inputRef = useRef(null);

  function focusInput() {
    inputRef.current.focus();
  }

  return (
    <>
      <input ref={inputRef} />
      <button onClick={focusInput}>Focus</button>
    </>
  );
}
```

Here:

- `useRef` stores a reference to a DOM element
- React assigns the DOM node to `ref.current`
- you can call DOM APIs directly

---

## Common use cases for `useRef`

Use `useRef` when you need to:

- access DOM elements
- store timers or intervals
- store previous values
- keep mutable values between renders
- avoid re-renders for non-UI data

---

## Example: storing previous value

```jsx
function Example({ value }) {
  const prevValue = useRef(value);

  useEffect(() => {
    prevValue.current = value;
  }, [value]);

  return (
    <div>
      Current: {value}, Previous: {prevValue.current}
    </div>
  );
}
```

Here:

- `prevValue.current` stores the previous value
- updating it does not cause a re-render

---

## What `useRef` does NOT do

- It does not trigger re-renders
- It does not notify React when values change
- It does not replace state
- It does not cause effects to re-run automatically

`useRef` is invisible to React’s rendering logic.

---

## Common mistakes

- Using `useRef` instead of state for UI data
- Expecting UI to update when `.current` changes
- Mutating refs and assuming React will react
- Overusing refs instead of proper state flow

> If changing a value should update the UI, it should be state, not a ref.

---

## Mental model

- State → drives rendering
- Ref → stores mutable values outside render flow
- State changes → re-render
- Ref changes → no re-render

Think of `useRef` as a **box React ignores during rendering**.

---

## Summary

- `useRef` stores mutable values across renders
- Updating `.current` does not cause re-renders
- Commonly used for DOM access and mutable values
- Refs are not reactive
- Use state for UI, refs for everything else
- `useRef` is a low-level escape hatch, not a default tool

# 2.02 useReducer

This file introduces the `useReducer` hook.
`useReducer` is an alternative to `useState` for managing **more complex state logic**.

---

## What `useReducer` is

`useReducer` is a React hook that allows a component to:

- manage state using a reducer function
- centralise state update logic
- make complex state transitions more predictable

It is commonly used when:

- state logic is complex
- state depends on previous state
- multiple related state values change together

---

## Basic idea

Instead of directly setting state, you:

1. **dispatch an action**
2. React calls the reducer
3. the reducer returns the new state
4. the component re-renders

State updates become **explicit and structured**.

---

## Basic syntax

```jsx
const [state, dispatch] = useReducer(reducer, initialState);
```

Here:

- `state` is the current state
- `dispatch` sends actions
- `reducer` is a function that decides how state changes
- `initialState` is the starting value

---

## Reducer function

A reducer is a **pure function**:

```jsx
function reducer(state, action) {
  switch (action.type) {
    case "increment":
      return { count: state.count + 1 };

    case "decrement":
      return { count: state.count - 1 };

    default:
      return state;
  }
}
```

The reducer:

- receives the current state
- receives an action
- returns the next state

It must **not** mutate state.

---

## Example

```jsx
function Counter() {
  const [state, dispatch] = useReducer(reducer, { count: 0 });

  return (
    <button onClick={() => dispatch({ type: "increment" })}>
      Count: {state.count}
    </button>
  );
}
```

## What happens here

- `state` is stored by React
- clicking the button dispatches an action
- React calls the reducer
- a new state object is returned
- the component re-renders
- the UI reflects the new state

---

## Actions

An **action** is a plain object that describes **what happened**:

```js
{
  type: "increment"
}
```

Actions:

- must have a `type`
- can include additional data (payload)
- describe intent, not implementation

---

## Why `useReducer` exists

`useReducer` helps when:

- state transitions must be predictable
- multiple updates depend on previous state
- logic becomes hard to follow with `useState`
- you want to separate **what happened** from **how state changes**

---

## useReducer vs useState

| useState         | useReducer           |
| ---------------- | -------------------- |
| Simple state     | Complex state logic  |
| Direct updates   | Action-based updates |
| Less boilerplate | More explicit        |
| Easier to start  | Easier to scale      |

Most components start with `useState`.  
`useReducer` is used when complexity grows.

---

## What `useReducer` does NOT do

- It does not eliminate re-renders
- It does not replace global state libraries
- It does not persist state automatically
- It does not allow mutable updates

---

## Common mistakes

- Mutating state inside the reducer
- Forgetting to return state in default case
- Putting side effects inside reducers
- Using `useReducer` when `useState` is sufficient

---

## Mental model

- `dispatch` → describes what happened
- `reducer` → decides how state changes
- state updates are predictable and explicit
- UI is derived from reducer state

---

## Summary

- `useReducer` manages state using actions and reducers
- Reducers are pure functions
- State updates go through `dispatch`
- Best for complex or related state logic
- `useState` for simple cases, `useReducer` for structured logic

# 2.03 useEffect

This file introduces the `useEffect` hook.
`useEffect` is used to run **side effects** in React components.

---

## What `useEffect` is

`useEffect` is a React hook that allows a component to:

- run code **after rendering**
- synchronise React with external systems
- handle side effects safely

Side effects are things that happen **outside** of rendering.

---

## What a side effect is

A **side effect** is any code that:

- interacts with the outside world
- is not purely calculating UI
- should not run during render

Common side effects include:

- data fetching
- subscriptions
- timers
- logging
- manually updating the DOM

---

## Basic syntax

```jsx
useEffect(() => {
  // side effect
}, [dependencies]);
```

Here:

- the function contains the side effect
- the dependency array controls when the effect runs

---

## Effect without dependencies

```jsx
useEffect(() => {
  console.log("Effect ran");
});
```

This effect:

- runs after every render

This is rarely what you want.

---

## Effect with empty dependency array

```jsx
useEffect(() => {
  console.log("Runs once");
}, []);
```

This effect:

- runs once after the first render
- behaves like “on mount”

Common use cases:

- initial data fetch
- setup logic

---

## Effect with dependencies

```jsx
useEffect(() => {
  console.log("Count changed:", count);
}, [count]);
```

This effect:

- runs after the first render (and cleanup runs on unmount)
- runs again whenever count changes

Only values listed in the dependency array trigger the effect.

---

## What happens when dependencies change

- component renders
- React compares dependency values
- if any dependency changed → effect runs
- component may re-render again

Effects always run **after rendering**.

---

## Cleanup function

An effect can return a cleanup function:

```jsx
useEffect(() => {
  const id = setInterval(() => {
    console.log("Tick");
  }, 1000);

  return () => {
    clearInterval(id);
  };
}, []);
```

Cleanup runs:

- before the effect runs again
- when the component unmounts

Used for:

- timers
- subscriptions
- event listeners

---

## useEffect and re-renders

- `useEffect` does not block rendering
- effects run after the UI is painted
- state updates inside effects cause re-renders

This is expected and normal.

---

## What `useEffect` does NOT do

- It does not replace lifecycle methods directly
- It does not run during render
- It does not automatically memoise values
- It does not fix bad state design

---

## Common mistakes

- Missing dependencies
- Using effects for derived state
- Infinite loops caused by state updates
- Putting logic in effects that belongs in render

> If you can do something during render, it probably does not belong in an effect.

---

## Mental model

- Render → describe UI
- Effect → synchronise with outside world
- Dependencies → control when synchronisation happens
- Cleanup → undo previous side effects

---

## Summary

- `useEffect` runs side effects after rendering
- Dependency array controls when it runs
- Empty array = run once
- Cleanup functions prevent leaks
- Effects synchronise React with external systems
- Rendering and side effects are separate concerns
